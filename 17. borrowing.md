# Borrowing

In real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we **referencing** the original binding; **borrow** the data of it.

> [Borrow \(verb\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  
> To receive something with the promise of returning it.


‚≠êÔ∏è There are two types of Borrowing,

1. **Shared Borrowing** `(&T)`

   * A piece of data can be **borrowed by a single or multiple users**, but **data should not be altered**.

2. **Mutable Borrowing** `(&mut T)`

   * A piece of data can be **borrowed and altered by a single user**, but the data should not be accessible for any other users at that time.
   

‚≠êÔ∏è And there are **very important rules** regarding borrowing,

1. One piece of data can be borrowed **either** as a shared borrow or as a mutable borrow **at a given time. But not both at the same time**.

2. Borrowing **applies for both copy types and move types**.

3. The concept of **Liveness** ‚Ü¥

```rust
fn main() {
  let mut a = vec![1, 2, 3];
  let b = &mut a;  //  &mut borrow of a starts here
                   //  ‚Åù
  // some code     //  ‚Åù
  // some code     //  ‚Åù
}                  //  &mut borrow of a ends here


fn main() {
  let mut a = vec![1, 2, 3];
  let b = &mut a;  //  &mut borrow of a starts here
  // some code

  println!("{:?}", a); // trying to access a as a shared borrow, so giving error
}                  //  &mut borrow of a ends here


fn main() {
  let mut a = vec![1, 2, 3];
  {
    let b = &mut a;  //  &mut borrow of a starts here
    // any other code
  }                  //  &mut borrow of a ends here

  println!("{:?}", a); // allow to borrow a as a shared borrow
}
```


üí° **Let‚Äôs see how to use shared and mutable borrowings in examples.**

```rust
fn main() {
    let a = [1, 2, 3];
    let b = &a;
    println!("{:?} {}", a, b[0]); // [1, 2, 3] 1
}


fn main() {
    let a = vec![1, 2, 3];
    let b = get_first_element(&a);
    
    println!("{:?} {}", a, b); // [1, 2, 3] 1
}

fn get_first_element(a: &Vec<i32>) -> i32 {
    a[0]
}
```






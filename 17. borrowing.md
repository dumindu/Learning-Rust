# Borrowing

In real life applications, most of the times we have to pass variable bindings to other functions or assign them to another variable bindings. In this case we **referencing** the original binding; **borrow** the data of it.

> [Borrow \(verb\)](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)  
> To receive something with the promise of returning it.

‚≠êÔ∏è There are two types of Borrowing,

1. **Shared Borrowing** `(&T)`

   * A piece of data can be **borrowed by a single or multiple users**, but **data should not be altered**.

2. **Mutable Borrowing** `(&mut T)`

   * A piece of data can be **borrowed and altered by a single user**, but the data should not be accessible for any other users at that time.

‚≠êÔ∏è And there are **very important rules** regarding borrowing,

1.One piece of data can be borrowed **either** as a shared borrow or as a mutable borrow **at a given time. But not both at the same time**.

1. Borrowing **applies for both copy types and move types**.

2. The concept of **Liveness** ‚Ü¥

```rust
fn main() {
  let mut a = vec![1, 2, 3];
  let b = &mut a;  //  &mut borrow of a starts here
                   //  ‚Åù
  // some code     //  ‚Åù
  // some code     //  ‚Åù
}                  //  &mut borrow of a ends here


fn main() {
  let mut a = vec![1, 2, 3];
  let b = &mut a;  //  &mut borrow of a starts here
  // some code

  println!("{:?}", a); // trying to access a as a shared borrow, so giving error
}                  //  &mut borrow of a ends here


fn main() {
  let mut a = vec![1, 2, 3];
  {
    let b = &mut a;  //  &mut borrow of a starts here
    // any other code
  }                  //  &mut borrow of a ends here

  println!("{:?}", a); // allow to borrow a as a shared borrow
}
```

üí° **Let‚Äôs see how to use shared and mutable borrowings in examples.**




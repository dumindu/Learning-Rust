# Lifetimes

When we are dealing with references, we have to make sure that the referencing data stay alive until we are stop using the references.

Think,
* We have a variable binding, â€œ**a**â€.
* We are referencing the value of â€œaâ€, from another variable binding â€œ**x**â€.
We have to make sure that â€œaâ€ **lives** until we stop using â€œxâ€

> ðŸ”Ž **Memory management** is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used **Manual Memory Management** which **requires the programmer to give manual instructions** to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented **Garbage collection**(GC), a form of **Automatic Memory Management**(AMM). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However **Objective-C and Swift** provide similar functionality through **Automatic Reference Counting**(ARC).


In Rust, 

* A resource can only have **one owner** at a time. When it goes **out of the scope**, Rust removes it from the Memory.
* When we want to reuse the same resource, we are **referencing** it/ **borrowing** its content. 
* When dealing with **references**, we have to specify **lifetime annotations** to provide instructions for the **compiler** to set **how long** those referenced resources **should be alive**.
* â­ï¸But because of lifetime annotations make **code more verbose**, in order to make **common patterns** more ergonomic, Rust allows lifetimes to be **elided/omitted** in `fn` definitions. In this case, the compiler assigns lifetime annotations **implicitly**.

Lifetime annotations are **checked at compile-time**. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in **run time**. This is the major reason of having **slower compilation times** in Rust.

> 
* Unlike C and C++, **usually** Rust doesnâ€™t explicitly drop values at all. 
* Unlike GC, Rust doesnâ€™t place deallocation calls where the data is no longer referenced.
* Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.

ðŸ’¡ Lifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually **starts with** `'a` and **follows alphabetic order** when we need to add **multiple lifetime** annotations.

When using references,

01. On **Function Declaration**

* Input and output parameters with references should attach lifetimes after `&` sign. ex `..(x: &'a str)` , `..(x: &'a mut str)` 
* After the function name, we should mention that the given lifetimes are generic types. ex `fn foo<'a>(..)` , `fn foo<'a, 'b>(..)`
 
```rust
// no inputs, return a reference
fn function<'a>() -> &'a str {} 

// single input
fn function<'a>(x: &'a str) {}

// single input and output, both has same lifetime
// output should live at least as long as input exists
fn function<'a>(x: &'a str) -> &'a str {}

// multiple inputs, only one input and the output share same lifetime
// output should live at least as long as y exists
fn function<'a>(x: i32, y: &'a str) -> &'a str {}

// multiple inputs. both inputs and the output share same lifetime
// output should live at least as long as x and y exist
fn function<'a>(x: &'a str, y: &'a str) -> &'a str {}

// multiple inputs. inputs can have diffent lifetimes ðŸ”Ž
// output should live at least as long as x exists
fn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {}
```

02. On **Struct or Enum Declaration**

* Elements with references should attach lifetimes after `&` sign.
* After the name of the struct or enum, we should mention that the given lifetimes are generic types.

```rust
// single element
// data of x should live at least as long as Struct exists
struct Struct<'a> { 
    x: &'a str 
}

// multiple elements
// data of x and y should live at least as long as Struct exists
struct Struct<'a> { 
    x: &'a str,
    y: &'a str 
}


// variant with single element
// data of the variant should live at least as long as Enum exists
enum Enum<'a> { 
    Variant(&'a Type)
}
```

03. With **Impls and Traits**

```rust
struct Struct<'a> { 
    x: &'a str 
}
    impl<'a> Struct<'a> { 
        fn function<'a>(&self) -> &'a str {
            self.x 
        }
    }


struct Struct<'a> { 
    x: &'a str,
    y: &'a str
}
    impl<'a> Struct<'a> { 
        fn new(x: &'a str, y: &'a str) -> Struct<'a> { //no need to specify <'a> after new; impl already has it
          Struct {
              x : x,
              y : y
          }
        }
    }


// ðŸ”Ž
impl<'a> Trait<'a> for Type
impl<'a> Trait for Type<'a>
```

04. With **Generic Types**

```rust
// ðŸ”Ž
fn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)
struct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }
enum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }
impl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } }
```

